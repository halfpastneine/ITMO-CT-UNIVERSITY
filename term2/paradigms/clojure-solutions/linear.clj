(defn v [v1 v2 sign] (mapv sign v1 v2))
(defn m [m1 m2 f] (mapv f m1 m2))
(defn v+ [v1 v2] (v v1 v2 +)) ; :NOTE: можно избавиться от [v1 v2] в списке аргументов
(defn v- [v1 v2] (v v1 v2 -))
(defn v* [v1 v2] (v v1 v2 *))
(defn vd [v1 v2] (v v1 v2 /))
(defn scalar [v1 v2] (apply + (vec (map * v1 v2))))
(defn vect [v1 v2] [(- (* (v1 1) (v2 2)) (* (v1 2) (v2 1)))
                    (- (- (* (v1 0) (v2 2)) (* (v1 2) (v2 0))))
                    (- (* (v1 0) (v2 1)) (* (v1 1) (v2 0)))])
(defn v*s [v a] (mapv #(* a %) v))
(defn m+ [m1 m2] (m m1 m2 v+))
(defn m- [m1 m2] (m m1 m2 v-))
(defn m* [m1 m2] (m m1 m2 v*))
(defn md [m1 m2] (m m1 m2 vd))
(defn m*s [m a] (mapv #(v*s % a) m))
(defn m*v [m v] (mapv #(scalar % v) m))
(defn transpose [m] (apply mapv vector m))
(defn m*m [m1 m2] (transpose(mapv #(m*v m1 %) (transpose m2))))
(defn c+ [v1 v2] (mapv m+ v1 v2))
(defn c- [v1 v2] (mapv m- v1 v2))
(defn c* [v1 v2] (mapv m* v1 v2))
(defn cd [v1 v2] (mapv md v1 v2))
